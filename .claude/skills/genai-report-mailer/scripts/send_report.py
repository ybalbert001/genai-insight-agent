#!/usr/bin/env python3
"""
GenAI Report Email Sender
Sends GenAI insight reports via email with geek-style HTML formatting
"""

import argparse
import smtplib
import sys
import os
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.image import MIMEImage
from email.utils import formataddr
from pathlib import Path
import re
import base64

try:
    import yaml
except ImportError:
    print("Error: pyyaml not installed. Install with: pip install pyyaml")
    sys.exit(1)

try:
    import markdown2
except ImportError:
    print("Error: markdown2 not installed. Install with: pip install markdown2")
    sys.exit(1)


class ReportMailer:
    """Email sender for GenAI insight reports"""

    def __init__(self, config_path):
        """
        Initialize mailer with configuration

        Args:
            config_path: Path to email config YAML file
        """
        self.config = self._load_config(config_path)
        self.config_dir = Path(config_path).parent

    def _load_config(self, config_path):
        """Load email configuration from YAML file"""
        try:
            with open(config_path, 'r') as f:
                config = yaml.safe_load(f)

            # Validate required fields
            required = ['smtp', 'sender', 'recipients']
            for field in required:
                if field not in config:
                    raise ValueError(f"Missing required field: {field}")

            # Resolve environment variables in password
            config = self._resolve_env_vars(config)

            return config
        except Exception as e:
            print(f"Error loading config: {e}")
            sys.exit(1)

    def _resolve_env_vars(self, config):
        """
        Resolve environment variables in config

        Supports:
        - ${ENV_VAR} format
        - Empty or missing password (reads from SMTP_PASSWORD)
        """
        # Handle SMTP password
        password = config.get('smtp', {}).get('password', '')

        if not password or password.strip() == '':
            # Empty password, try SMTP_PASSWORD env var
            password = os.environ.get('SMTP_PASSWORD', '')
            if not password:
                raise ValueError("SMTP password not set. Set SMTP_PASSWORD environment variable or add password to config.")
        elif password.startswith('${') and password.endswith('}'):
            # ${ENV_VAR} format
            env_var = password[2:-1]
            password = os.environ.get(env_var, '')
            if not password:
                raise ValueError(f"Environment variable {env_var} not set")

        config['smtp']['password'] = password

        return config

    def convert_markdown_to_html(self, markdown_path):
        """
        Convert Markdown report to HTML with geek-style CSS

        Args:
            markdown_path: Path to Markdown report file

        Returns:
            HTML string with embedded CSS
        """
        # Read Markdown content
        with open(markdown_path, 'r', encoding='utf-8') as f:
            markdown_content = f.read()

        # Convert Markdown to HTML
        html_body = markdown2.markdown(
            markdown_content,
            extras=['tables', 'fenced-code-blocks', 'header-ids']
        )

        # Get geek-style CSS
        css = self._get_geek_style_css()

        # Build complete HTML
        html = f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GenAI Insight Report</title>
    <style>{css}</style>
</head>
<body>
    <div class="container">
        {html_body}
        <footer>
            <p>Generated by GenAI Insight Reporter | Powered by Claude</p>
        </footer>
    </div>
</body>
</html>"""

        # Replace image paths with inline CID references
        html = self._replace_image_paths_with_cid(html, markdown_path)

        return html

    def _replace_image_paths_with_cid(self, html, markdown_path):
        """
        Replace image paths with CID references for inline embedding

        Args:
            html: HTML content
            markdown_path: Path to original markdown file (for resolving image paths)

        Returns:
            HTML with CID references
        """
        markdown_dir = Path(markdown_path).parent

        # Find all image tags
        img_pattern = r'<img\s+[^>]*src="([^"]+)"[^>]*>'

        def replace_img(match):
            img_path = match.group(1)

            # Resolve relative paths
            if not img_path.startswith(('http://', 'https://', 'cid:')):
                full_path = (markdown_dir / img_path).resolve()

                # Generate CID from filename
                cid = Path(img_path).name.replace('.', '_')

                # Replace src with cid
                return match.group(0).replace(f'src="{img_path}"', f'src="cid:{cid}"')

            return match.group(0)

        return re.sub(img_pattern, replace_img, html)

    def _get_geek_style_css(self):
        """Get geek-style CSS for email HTML"""
        return """
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: #0d1117;
            color: #c9d1d9;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            line-height: 1.6;
            padding: 20px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            background-color: #161b22;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 30px;
        }

        h1 {
            color: #58a6ff;
            font-size: 32px;
            font-weight: bold;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #21262d;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        h2 {
            color: #f85149;
            font-size: 24px;
            font-weight: bold;
            margin-top: 30px;
            margin-bottom: 15px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        h3 {
            color: #56d364;
            font-size: 20px;
            font-weight: bold;
            margin-top: 20px;
            margin-bottom: 10px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        h4 {
            color: #ffa657;
            font-size: 18px;
            font-weight: bold;
            margin-top: 15px;
            margin-bottom: 10px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        p {
            margin-bottom: 15px;
        }

        blockquote {
            border-left: 4px solid #58a6ff;
            padding-left: 15px;
            margin: 15px 0;
            color: #8b949e;
        }

        a {
            color: #58a6ff;
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        strong {
            color: #f0f6fc;
            font-weight: bold;
        }

        code {
            background-color: #0d1117;
            color: #ff7b72;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
            font-size: 13px;
        }

        pre {
            background-color: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 15px;
            overflow-x: auto;
            margin: 15px 0;
        }

        pre code {
            background-color: transparent;
            padding: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background-color: #0d1117;
            border: 1px solid #30363d;
        }

        th {
            background-color: #21262d;
            color: #58a6ff;
            padding: 12px;
            text-align: left;
            font-weight: bold;
            border: 1px solid #30363d;
        }

        td {
            padding: 10px 12px;
            border: 1px solid #30363d;
        }

        tr:hover {
            background-color: #161b22;
        }

        img {
            max-width: 100%;
            height: auto;
            display: block;
            margin: 20px auto;
            border-radius: 6px;
            border: 1px solid #30363d;
        }

        hr {
            border: none;
            border-top: 1px solid #21262d;
            margin: 30px 0;
        }

        ul, ol {
            margin: 15px 0 15px 30px;
        }

        li {
            margin-bottom: 8px;
        }

        footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid #21262d;
            text-align: center;
            color: #8b949e;
            font-size: 12px;
        }

        /* Metric highlights */
        .metric {
            background-color: #0d1117;
            border-left: 3px solid #56d364;
            padding: 10px 15px;
            margin: 10px 0;
            border-radius: 3px;
        }

        .metric strong {
            color: #79c0ff;
        }
        """

    def attach_images(self, msg, markdown_path):
        """
        Attach images as inline attachments

        Args:
            msg: MIMEMultipart message object
            markdown_path: Path to markdown file
        """
        markdown_dir = Path(markdown_path).parent

        # Find image references in markdown
        with open(markdown_path, 'r', encoding='utf-8') as f:
            content = f.read()

        # Find all image paths
        img_pattern = r'!\[.*?\]\(([^)]+)\)'
        image_paths = re.findall(img_pattern, content)

        for img_path in image_paths:
            # Skip external URLs
            if img_path.startswith(('http://', 'https://')):
                continue

            # Resolve path
            full_path = (markdown_dir / img_path).resolve()

            if not full_path.exists():
                print(f"Warning: Image not found: {full_path}")
                continue

            # Read image
            try:
                with open(full_path, 'rb') as f:
                    img_data = f.read()

                # Create MIMEImage
                image = MIMEImage(img_data)

                # Set CID (Content-ID)
                cid = full_path.name.replace('.', '_')
                image.add_header('Content-ID', f'<{cid}>')
                image.add_header('Content-Disposition', 'inline', filename=full_path.name)

                # Attach to message
                msg.attach(image)
                print(f"Attached image: {full_path.name} (CID: {cid})")

            except Exception as e:
                print(f"Warning: Failed to attach image {full_path}: {e}")

    def send_email(self, markdown_path, subject=None, dry_run=False):
        """
        Send email with report

        Args:
            markdown_path: Path to Markdown report file
            subject: Custom subject line (optional)
            dry_run: If True, only preview HTML without sending

        Returns:
            True if successful, False otherwise
        """
        try:
            # Generate HTML
            print("Converting Markdown to HTML...")
            html_content = self.convert_markdown_to_html(markdown_path)

            # Read plain text version
            with open(markdown_path, 'r', encoding='utf-8') as f:
                plain_content = f.read()

            if dry_run:
                # Save preview
                preview_path = 'preview.html'
                with open(preview_path, 'w', encoding='utf-8') as f:
                    f.write(html_content)
                print(f"✅ Preview saved to: {preview_path}")
                print("Open in browser to view")
                return True

            # Build subject
            if not subject:
                # Extract date from report filename
                filename = Path(markdown_path).stem
                date_match = re.search(r'(\d{4})(\d{2})(\d{2})', filename)
                if date_match:
                    date_str = f"{date_match.group(1)}-{date_match.group(2)}-{date_match.group(3)}"
                else:
                    date_str = "Latest"

                subject_prefix = self.config.get('email', {}).get('subject_prefix', '[GenAI Insight]')
                subject = f"{subject_prefix} Report - {date_str}"

            # Create message
            msg = MIMEMultipart('related')
            msg['Subject'] = subject
            msg['From'] = formataddr((
                self.config['sender']['name'],
                self.config['sender']['email']
            ))
            msg['To'] = ', '.join(self.config['recipients']['to'])

            if self.config['recipients'].get('cc'):
                msg['Cc'] = ', '.join(self.config['recipients']['cc'])

            if self.config.get('email', {}).get('reply_to'):
                msg['Reply-To'] = self.config['email']['reply_to']

            # Create alternative part for HTML and plain text
            msg_alternative = MIMEMultipart('alternative')
            msg.attach(msg_alternative)

            # Attach plain text version
            msg_alternative.attach(MIMEText(plain_content, 'plain', 'utf-8'))

            # Attach HTML version
            msg_alternative.attach(MIMEText(html_content, 'html', 'utf-8'))

            # Attach images
            print("Attaching images...")
            self.attach_images(msg, markdown_path)

            # Send email
            print(f"Connecting to SMTP server: {self.config['smtp']['host']}:{self.config['smtp']['port']}")

            # Build recipient list
            all_recipients = list(self.config['recipients']['to'])
            if self.config['recipients'].get('cc'):
                all_recipients.extend(self.config['recipients']['cc'])
            if self.config['recipients'].get('bcc'):
                all_recipients.extend(self.config['recipients']['bcc'])

            # Connect and send
            smtp_config = self.config['smtp']

            # Determine connection type
            if smtp_config.get('use_ssl', False):
                # SSL connection (port 465 typically)
                server = smtplib.SMTP_SSL(smtp_config['host'], smtp_config['port'])
            elif smtp_config.get('use_tls', True):
                # TLS connection (port 587 typically)
                server = smtplib.SMTP(smtp_config['host'], smtp_config['port'])
                server.starttls()
            else:
                # Plain connection (not recommended)
                server = smtplib.SMTP(smtp_config['host'], smtp_config['port'])

            server.login(smtp_config['username'], smtp_config['password'])
            server.send_message(msg, to_addrs=all_recipients)
            server.quit()

            print(f"✅ Email sent successfully!")
            print(f"   Subject: {subject}")
            print(f"   To: {', '.join(self.config['recipients']['to'][:3])}" +
                  (f" and {len(self.config['recipients']['to'])-3} more"
                   if len(self.config['recipients']['to']) > 3 else ""))

            return True

        except Exception as e:
            print(f"❌ Error sending email: {e}")
            import traceback
            traceback.print_exc()
            return False


def main():
    """Main entry point"""
    parser = argparse.ArgumentParser(
        description='Send GenAI insight reports via email'
    )
    parser.add_argument(
        '--report',
        required=True,
        help='Path to Markdown report file'
    )
    parser.add_argument(
        '--config',
        required=True,
        help='Path to email config YAML file'
    )
    parser.add_argument(
        '--subject',
        help='Custom email subject line'
    )
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Preview HTML without sending email'
    )

    args = parser.parse_args()

    # Validate paths
    if not Path(args.report).exists():
        print(f"Error: Report file not found: {args.report}")
        sys.exit(1)

    if not Path(args.config).exists():
        print(f"Error: Config file not found: {args.config}")
        sys.exit(1)

    # Send email
    mailer = ReportMailer(args.config)
    success = mailer.send_email(
        args.report,
        subject=args.subject,
        dry_run=args.dry_run
    )

    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
